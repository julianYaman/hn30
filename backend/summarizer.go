package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"hn30/backend/utils"
	"io"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/go-shiori/go-readability"
)

var summarizerClient = &http.Client{
	Timeout: 10 * time.Second,
}

type OpenRouterRequest struct {
	Model    string              `json:"model"`
	Messages []OpenRouterMessage `json:"messages"`
}

type OpenRouterResponse struct {
	ID      string `json:"id"`
	Choices []struct {
		Message OpenRouterMessage `json:"message"`
	} `json:"choices"`
	Model string `json:"model"`
}

type OpenRouterMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type SummaryResponse struct {
	Summary string `json:"summary"`
	Model   string `json:"model"`
}

func generateSummary(articleText string) (SummaryResponse, error) {
	utils.LogComponent("AI", "Generating summary using OpenRouter")

	if articleText == "" {
		return SummaryResponse{}, fmt.Errorf("Either no article text was provided for summarization or it could not be parsed.")
	}

	apiKey := os.Getenv("OPENROUTER_API_KEY")
	if apiKey == "" {
		panic("Please set OPENROUTER_API_KEY")
	}

	body := OpenRouterRequest{
		Model: "@preset/hn30-summary",
		Messages: []OpenRouterMessage{
			{
				Role:    "user",
				Content: articleText,
			},
		},
	}

	jsonBody, _ := json.Marshal(body)

	req, err := http.NewRequest("POST", "https://openrouter.ai/api/v1/chat/completions", bytes.NewBuffer(jsonBody))

	if err != nil {
		utils.LogComponent("AI", "Failed to marshal OpenRouter request: %v", err)
		return SummaryResponse{}, fmt.Errorf("AI Provider could not generate summary.")
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("HTTP-Referer", "https://hn30.yamanlabs.com")
	req.Header.Set("X-Title", "hn30")

	client := &http.Client{}
	res, err := client.Do(req)

	if err != nil {
		utils.LogComponent("AI", "OpenRouter request error: %v", err)
		return SummaryResponse{}, fmt.Errorf("AI Provider could not generate summary.")
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		utils.LogComponent("AI", "OpenRouter returned non-200 status: %d", res.StatusCode)
		bodyBytes, _ := io.ReadAll(res.Body)
		utils.LogComponent("AI", "OpenRouter response body: %s", string(bodyBytes))
		return SummaryResponse{}, fmt.Errorf("AI Provider could not generate summary.")
	}

	var openRouterResp OpenRouterResponse
	if err := json.NewDecoder(res.Body).Decode(&openRouterResp); err != nil {
		fmt.Printf("Error decoding response: %v\n", err)
		return SummaryResponse{}, fmt.Errorf("Could not read AI Provider response.")
	}

	if len(openRouterResp.Choices) == 0 {
		utils.LogComponent("AI", "No choices returned from OpenRouter")
		return SummaryResponse{}, fmt.Errorf("No summary generated by AI Provider.")
	}

	summary := openRouterResp.Choices[0].Message.Content
	utils.LogComponent("AI", "Successfully generated summary using OpenRouter")
	return SummaryResponse{Summary: summary, Model: openRouterResp.Model}, nil

}

func extractArticleText(articleURL string) (string, error) {
	utils.LogComponent("SCRAPER", "Extracting article text from %s", articleURL)

	// Create a new request so we can set headers
	req, err := http.NewRequest("GET", articleURL, nil)
	if err != nil {
		return "", err
	}

	// Set the custom user agent and other common browser headers
	req.Header.Set("User-Agent", customUserAgent)
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9")

	resp, err := summarizerClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to fetch URL: status %d", resp.StatusCode)
	}

	parsedURL, err := url.Parse(articleURL)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %v", err)
	}

	article, err := readability.FromReader(resp.Body, parsedURL)
	if err != nil {
		return "", err
	}

	utils.LogComponent("SCRAPER", "Successfully extracted article text for %s", articleURL)
	return article.TextContent, nil
}
