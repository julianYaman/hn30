package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"os"
	"time"

	"github.com/go-shiori/go-readability"
)

var summarizerClient = &http.Client{
	Timeout: 10 * time.Second,
}

type OpenRouterRequest struct {
	Model    string              `json:"model"`
	Messages []OpenRouterMessage `json:"messages"`
}

type OpenRouterResponse struct {
	ID      string `json:"id"`
	Choices []struct {
		Message OpenRouterMessage `json:"message"`
	} `json:"choices"`
	Model string `json:"model"`
}

type OpenRouterMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type SummaryResponse struct {
	Summary string `json:"summary"`
	Model   string `json:"model"`
}

func generateSummary(articleText string) (SummaryResponse, error) {
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil)).With(
		"event_type", "ai_operation",
		"operation", "generate_summary",
		"provider", "openrouter",
	)
	start := time.Now()

	if articleText == "" {
		logger.Error("article text missing",
			"event", "validation_failed",
			"error", "no article text provided",
		)
		return SummaryResponse{}, fmt.Errorf("Either no article text was provided for summarization or it could not be parsed.")
	}

	apiKey := os.Getenv("OPENROUTER_API_KEY")
	if apiKey == "" {
		logger.Error("api key missing",
			"event", "configuration_error",
			"error", "OPENROUTER_API_KEY not set",
		)
		panic("Please set OPENROUTER_API_KEY")
	}

	logger.Info("generating ai summary",
		"event", "summary_generation_started",
		"article_length", len(articleText),
		"model", "@preset/hn30-summary",
	)

	body := OpenRouterRequest{
		Model: "@preset/hn30-summary",
		Messages: []OpenRouterMessage{
			{
				Role:    "user",
				Content: articleText,
			},
		},
	}

	jsonBody, _ := json.Marshal(body)

	req, err := http.NewRequest("POST", "https://openrouter.ai/api/v1/chat/completions", bytes.NewBuffer(jsonBody))

	if err != nil {
		logger.Error("request creation failed",
			"event", "request_creation_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return SummaryResponse{}, fmt.Errorf("AI Provider could not generate summary.")
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("HTTP-Referer", "https://hn30.yamanlabs.com")
	req.Header.Set("X-Title", "hn30")

	logger.Info("sending request to openrouter",
		"event", "api_request_started",
		"request_size", len(jsonBody),
	)

	client := &http.Client{}
	res, err := client.Do(req)

	if err != nil {
		logger.Error("openrouter request failed",
			"event", "api_request_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return SummaryResponse{}, fmt.Errorf("AI Provider could not generate summary.")
	}
	defer res.Body.Close()

	logger.Info("response received from openrouter",
		"event", "api_response_received",
		"status_code", res.StatusCode,
		"content_length", res.ContentLength,
	)

	if res.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(res.Body)
		logger.Error("openrouter returned error",
			"event", "api_error_response",
			"status_code", res.StatusCode,
			"response_body", string(bodyBytes),
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return SummaryResponse{}, fmt.Errorf("AI Provider could not generate summary.")
	}

	var openRouterResp OpenRouterResponse
	if err := json.NewDecoder(res.Body).Decode(&openRouterResp); err != nil {
		logger.Error("response decode failed",
			"event", "json_decode_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return SummaryResponse{}, fmt.Errorf("Could not read AI Provider response.")
	}

	if len(openRouterResp.Choices) == 0 {
		logger.Error("no choices in response",
			"event", "empty_response",
			"response_id", openRouterResp.ID,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return SummaryResponse{}, fmt.Errorf("No summary generated by AI Provider.")
	}

	summary := openRouterResp.Choices[0].Message.Content

	logger.Info("summary generated successfully",
		"event", "summary_generation_completed",
		"response_id", openRouterResp.ID,
		"model_used", openRouterResp.Model,
		"summary_length", len(summary),
		"duration_ms", time.Since(start).Milliseconds(),
	)

	return SummaryResponse{Summary: summary, Model: openRouterResp.Model}, nil
}

func extractArticleText(articleURL string) (string, error) {
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil)).With(
		"event_type", "article_extraction",
		"operation", "extract_text",
		"url", articleURL,
	)
	start := time.Now()

	logger.Info("extracting article text",
		"event", "extraction_started",
	)

	// Create a new request so we can set headers
	req, err := http.NewRequest("GET", articleURL, nil)
	if err != nil {
		logger.Error("request creation failed",
			"event", "request_creation_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return "", err
	}

	// Set the custom user agent and other common browser headers
	req.Header.Set("User-Agent", customUserAgent)
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.9")

	resp, err := summarizerClient.Do(req)
	if err != nil {
		logger.Error("http request failed",
			"event", "http_request_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return "", err
	}
	defer resp.Body.Close()

	logger.Info("response received",
		"event", "response_received",
		"status_code", resp.StatusCode,
		"content_length", resp.ContentLength,
	)

	if resp.StatusCode != http.StatusOK {
		logger.Error("non-ok status code",
			"event", "non_ok_status",
			"status_code", resp.StatusCode,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return "", fmt.Errorf("failed to fetch URL: status %d", resp.StatusCode)
	}

	parsedURL, err := url.Parse(articleURL)
	if err != nil {
		logger.Error("url parsing failed",
			"event", "url_parse_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return "", fmt.Errorf("invalid URL: %v", err)
	}

	article, err := readability.FromReader(resp.Body, parsedURL)
	if err != nil {
		logger.Error("readability parsing failed",
			"event", "readability_failed",
			"error", err,
			"duration_ms", time.Since(start).Milliseconds(),
		)
		return "", err
	}

	logger.Info("article text extracted successfully",
		"event", "extraction_completed",
		"article_title", article.Title,
		"text_length", len(article.TextContent),
		"duration_ms", time.Since(start).Milliseconds(),
	)

	return article.TextContent, nil
}
